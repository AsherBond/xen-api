---
title: 'Walkthrough: Migrating a VM'
linktitle: 'Migrating a VM'
description: Walkthrough of migrating a VM from one host to another.
weight: 50
mermaid:
  force: true
---
At the end of this walkthrough, a sequence diagram of the overall process is included.

## Invocation

The command to migrate the VM is dispatched
by the autogenerated `dispatch_call` function from **xapi/server.ml**. For
more information about the generated functions you can have a look to
[XAPI IDL model](https://github.com/xapi-project/xen-api/tree/master/ocaml/idl/ocaml_backend).

The command triggers the operation
[VM_migrate](https://github.com/xapi-project/xen-api/blob/7ac88b90e762065c5ebb94a8ea61c61bdbf62c5c/ocaml/xenopsd/lib/xenops_server.ml#L2572)
that uses many low level atomics operations. These are:

- [VM.restore](#VM-restore)
- [VM.rename](#VM-rename)
- [VBD.set_active](#restoring-devices)
- [VBD.plug](#restoring-devices)
- [VIF.set_active](#restoring-devices)
- [VGPU.set_active](#restoring-devices)
- [VM.create_device_model](#creating-the-device-model)
- [PCI.plug](#pci-plug)

The migrate command has several parameters such as:

- Should it be started asynchronously,
- Should it be forwarded to another host,
- How arguments should be marshalled, and so on.

A new thread is created by [xapi/server_helpers.ml](https://github.com/xapi-project/xen-api/blob/7ac88b90e762065c5ebb94a8ea61c61bdbf62c5c/ocaml/xapi/server_helpers.ml#L55)
to handle the command asynchronously. The helper thread checks if
the command should be passed to the [message forwarding](https://github.com/xapi-project/xen-api/blob/master/ocaml/xapi/message_forwarding.ml)
layer in order to be executed on another host (the destination) or locally (if
it is already at the destination host).

It will finally reach [xapi/api_server.ml](https://github.com/xapi-project/xen-api/blob/7ac88b90e762065c5ebb94a8ea61c61bdbf62c5c/ocaml/xapi/api_server.ml#L242) that will take the action
of posted a command to the message broker [message switch](https://github.com/xapi-project/xen-api/tree/master/ocaml/message-switch).
It is a JSON-RPC HTTP request sends on a Unix socket to communicate between some
XAPI daemons. In the case of the migration this message sends by **XAPI** will be
consumed by the [xenopsd](https://github.com/xapi-project/xen-api/tree/master/ocaml/xenopsd)
daemon that will do the job of migrating the VM.

## Overview

The migration is an asynchronous task and a thread is created to handle this task.
The task reference is returned to the client, which can then check
its status until completion.

As shown in the introduction, [xenopsd](https://github.com/xapi-project/xen-api/tree/master/ocaml/xenopsd)
fetches the
[VM_migrate](https://github.com/xapi-project/xen-api/blob/7ac88b90e762065c5ebb94a8ea61c61bdbf62c5c/ocaml/xenopsd/lib/xenops_server.ml#L2572)
operation from the message broker.

All tasks specific to [libxenctrl](../../lib/xenctrl),
[xenguest](VM.build/xenguest) and [Xenstore](https://wiki.xenproject.org/wiki/XenStore)
are handled by the xenopsd
[xc backend](https://github.com/xapi-project/xen-api/tree/master/ocaml/xenopsd/xc).

The entities that need to be migrated are: *VDI*, *VIF*, *VGPU* and *PCI* components.

During the migration process, the destination domain will be built with the same
UUID as the original VM, except that the last part of the UUID will be
`XXXXXXXX-XXXX-XXXX-XXXX-000000000001`. The original domain will be removed using
`XXXXXXXX-XXXX-XXXX-XXXX-000000000000`.

## Preparing VM migration

At specific places, `xenopsd` can execute *hooks* to run scripts.
In case a pre-migrate script is in place, a command to run this script
is sent to the original domain.

Likewise, a command is sent to Qemu using the Qemu Machine Protocol (QMP)
to check that the domain can be suspended (see [xenopsd/xc/device_common.ml](https://github.com/xapi-project/xen-api/blob/master/ocaml/xenopsd/xc/device_common.ml)).
After checking with Qemu that the VM is can be suspended, the migration can begin.

## Importing metadata

As for *hooks*, commands to source domain are sent using [stunnel](https://github.com/xapi-project/xen-api/tree/master/ocaml/libs/stunnel) a daemon which
is used as a wrapper to manage SSL encryption communication between two hosts on the same
pool. To import the metadata, an XML RPC command is sent to the original domain.

Once imported, it will give us a reference id and will allow building the new domain
on the destination using the temporary VM uuid `XXXXXXXX-XXXX-XXXX-XXXX-000000000001`
where `XXX...` is the reference id of the original VM.

## Memory setup

One of the first steps the setup of the VM's memory: The backend checks that there
is no ballooning operation in progress. If so, the migration could fail.

Once memory has been checked, the daemon will get the state of the VM (running, halted, ...) and
The backend retrieves the domain's platform data (memory, vCPUs setc) from the Xenstore.

Once this is complete, we can restore VIF and create the domain.

The synchronisation of the memory is the first point of synchronisation and everything
is ready for VM migration.

## Destination VM setup

After receiving memory we can set up the destination domain. If we have a vGPU we need to kick
off its migration process. We will need to wait for the acknowledgement that the
GPU entry has been successfully initialized before starting the main VM migration.

The receiver informs the sender using a handshake protocol
that everything is set up and ready for save/restore.

## Destination VM restore

VM restore is a low level atomic operation [VM.restore](https://github.com/xapi-project/xen-api/blob/7ac88b90e762065c5ebb94a8ea61c61bdbf62c5c/ocaml/xenopsd/xc/xenops_server_xen.ml#L2684).
This operation is represented by a function call to [backend](https://github.com/xapi-project/xen-api/blob/7ac88b90e762065c5ebb94a8ea61c61bdbf62c5c/ocaml/xenopsd/xc/domain.ml#L1540).
It uses **Xenguest**, a low-level utility from XAPI toolstack, to interact with the Xen hypervisor
and `libxc` for sending a migration request to the **emu-manager**.

After sending the request results coming from **emu-manager** are collected
by the main thread. It blocks until results are received.

During the live migration, **emu-manager** helps in ensuring the correct state
transitions for the devices and handling the message passing for the VM as
it's moved between hosts. This includes making sure that the state of the
VM's virtual devices, like disks or network interfaces, is correctly moved over.

## Destination VM rename

Once all operations are done, `xenopsd` renames the target VM from its temporary
name to its real UUID. This operation is a low-level atomic
[VM.rename](https://github.com/xapi-project/xen-api/blob/7ac88b90e762065c5ebb94a8ea61c61bdbf62c5c/ocaml/xenopsd/xc/xenops_server_xen.ml#L1667)
which takes care of updating the Xenstore on the destination host.

## Restoring devices

Restoring devices starts by activating VBD using the low level atomic operation
[VBD.set_active](https://github.com/xapi-project/xen-api/blob/7ac88b90e762065c5ebb94a8ea61c61bdbf62c5c/ocaml/xenopsd/xc/xenops_server_xen.ml#L3674). It is an update of Xenstore. VBDs that are read-write must
be plugged before read-only ones. Once activated the low level atomic operation
[VBD.plug](https://github.com/xapi-project/xen-api/blob/7ac88b90e762065c5ebb94a8ea61c61bdbf62c5c/ocaml/xenopsd/xc/xenops_server_xen.ml#L3721)
is called. VDI are attached and activate.

Next devices are VIFs that are set as active [VIF.set_active](https://github.com/xapi-project/xen-api/blob/7ac88b90e762065c5ebb94a8ea61c61bdbf62c5c/ocaml/xenopsd/xc/xenops_server_xen.ml#L4296) and plug [VIF.plug](https://github.com/xapi-project/xen-api/blob/7ac88b90e762065c5ebb94a8ea61c61bdbf62c5c/ocaml/xenopsd/xc/xenops_server_xen.ml#L4394).
If there are VGPUs we will set them as active now using the atomic [VGPU.set_active](https://github.com/xapi-project/xen-api/blob/7ac88b90e762065c5ebb94a8ea61c61bdbf62c5c/ocaml/xenopsd/xc/xenops_server_xen.ml#L3490).

### Creating the device model

[create_device_model](https://github.com/xapi-project/xen-api/blob/ec3b62ee/ocaml/xenopsd/xc/xenops_server_xen.ml#L2293-L2349)
configures **qemu-dm** and starts it. This allows to manage PCI devices.

### PCI plug

[PCI.plug](https://github.com/xapi-project/xen-api/blob/7ac88b90e762065c5ebb94a8ea61c61bdbf62c5c/ocaml/xenopsd/xc/xenops_server_xen.ml#L3399)
is executed by the backend. It plugs a PCI device and advertises it to QEMU if this option is set. It is
the case for NVIDIA SR-IOV vGPUs.

## Unpause

The libxenctrl call
[xc_domain_unpause()](https://github.com/xen-project/xen/blob/414dde3/tools/libs/ctrl/xc_domain.c#L76)
unpauses the domain, and it starts running.

## Cleanup

1. [VM_set_domain_action_request](https://github.com/xapi-project/xen-api/blob/ec3b62ee/ocaml/xenopsd/lib/xenops_server.ml#L3004)
   marks the domain as alive: In case `xenopsd` restarts, it no longer reboots the VM.
   See the chapter on [marking domains as alive](VM.start#11-mark-the-domain-as-alive)
   for more information.

2. If a post-migrate script is in place, it is executed by the
   [Xenops_hooks.VM_post_migrate](https://github.com/xapi-project/xen-api/blob/ec3b62ee/ocaml/xenopsd/lib/xenops_server.ml#L3005-L3009)
   hook.

3. The final step is a handshake to seal the success of the migration
and the old VM can now be cleaned up.

[Syncronisation point 4](https://github.com/xapi-project/xen-api/blob/ec3b62ee/ocaml/xenopsd/lib/xenops_server.ml#L3014)
has been reached, the migration is complete.

## Live migration flowchart

This flowchart gives a visual representation of the VM migration workflow:

{{% include live-migration %}}

## References

These pages might help for a better understanding of the XAPI toolstack:

- See the [XAPI architecture](../../xapi/_index) for the overall architecture of Xapi
- See the [XAPI dispatcher](https://wiki.xenproject.org/wiki/XAPI_Dispatch) for service dispatch and message forwarding
- See the [Xenopsd architecture](../architecture/_index) for the overall architecture of Xenopsd
- See the [How Xen suspend and resume works](https://mirage.io/docs/xen-suspend) for very similar operations in more detail.
