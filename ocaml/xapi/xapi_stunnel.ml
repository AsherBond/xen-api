(*
 * Copyright (C) Citrix Systems Inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation; version 2.1 only. with the special
 * exception on linking described in file LICENSE.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *)

open Xapi_stdext_threads.Threadext
module Unixext = Xapi_stdext_unix.Unixext

module D = Debug.Make (struct let name = "stunnel" end)

open D

let cert = !Xapi_globs.server_cert_path

let pool_cert = !Xapi_globs.server_cert_internal_path

(** protect ourselves from concurrent writes to files *)
module Config : sig
  val update : accept:string -> unit
  (** create or update stunnel config file *)
end = struct
  let m = Mutex.create ()

  let current_accept = ref None

  let rewrite_xapi_ssl_config_file ~accept =
    let fips =
      Xapi_inventory.lookup ~default:"false" "CC_PREPARATIONS" |> function
      | "true" ->
          "yes"
      | "false" ->
          "no"
      | unknown ->
          info
            "CC_PREPARATIONS has unexpected value '%s'. assuming fips mode \
             should be disabled"
            unknown ;
          "no"
    in
    let conf_contents =
      String.concat "\n"
        [
          "; autogenerated by xapi"
        ; Printf.sprintf "fips = %s" fips
        ; "pid = /var/run/xapissl.pid"
        ; "socket = r:TCP_NODELAY=1"
        ; "socket = a:TCP_NODELAY=1"
        ; "socket = l:TCP_NODELAY=1"
        ; "socket = r:SO_KEEPALIVE=1"
        ; "socket = a:SO_KEEPALIVE=1"
        ; ( match Sys.getenv_opt "STUNNEL_IDLE_TIMEOUT" with
          | None ->
              "; no idle timeout"
          | Some x ->
              Printf.sprintf "TIMEOUTidle = %s" x
          )
        ; Stunnel.debug_conf_of_env ()
        ; "protocol = proxy" (* tells stunnel to include inet address info *)
        ; ""
        ; "[xapi]"
        ; Printf.sprintf "accept = %s" accept
        ; "connect = 80"
        ; Printf.sprintf "cert = %s" cert
        ; Printf.sprintf "ciphers = %s" Xcp_const.good_ciphersuites
        ; "curve = secp384r1"
        ; "TIMEOUTclose = 1"
        ; "options = CIPHER_SERVER_PREFERENCE"
        ; "sslVersion = TLSv1.2"
        ; ""
        ; "# xapi connections use SNI 'pool' to request a cert"
        ; "# the options from [xapi] are inherited unless overridden below"
        ; "[pool]"
        ; "connect = 80"
        ; "sni = xapi:pool"
        ; Printf.sprintf "cert = %s" pool_cert
        ]
    in
    let len = String.length conf_contents in
    Unixext.atomic_write_to_file !Xapi_globs.stunnel_conf 0o0600 (fun fd ->
        let (_ : int) = Unix.single_write_substring fd conf_contents 0 len in
        ()
    )

  let update ~accept =
    Mutex.execute m (fun () ->
        match !current_accept with
        | Some current_accept when current_accept = accept ->
            ()
        | None | Some _ ->
            current_accept := Some accept ;
            rewrite_xapi_ssl_config_file ~accept
    )
end

let systemctl cmd =
  Helpers.call_script !Xapi_globs.systemctl [cmd; "stunnel@xapi"]

let systemctl_ cmd = systemctl cmd |> ignore

let reload () = systemctl_ "reload-or-restart"

let is_enabled () =
  let is_enabled_stdout =
    try systemctl "is-enabled"
    with
    (* systemctl is-enabled appears to return error code 1 when the service is disabled *)
    | Forkhelpers.Spawn_internal_error (stderr, stdout, status) as e -> (
      match status with
      | Unix.WEXITED n
        when n = 1
             && Astring.String.is_prefix ~affix:"disabled" stdout
             && Astring.String.is_empty stderr ->
          "disabled"
      | _ ->
          raise e
    )
  in
  is_enabled_stdout |> Astring.String.trim |> function
  | "enabled" ->
      true
  | "disabled" ->
      false
  | unknown ->
      D.error
        "Stunnel.is_enabled: expected 'enabled' or 'disabled', but got: %s"
        unknown ;
      false

let update_certificates ~__context () =
  info "syncing certificates on xapi start" ;
  match Certificates_sync.update ~__context with
  | Ok () ->
      info "successfully synced certificates"
  | Error (`Msg (msg, _)) ->
      error "Failed to update host certificates: %s" msg
  | exception e ->
      error "Failed to update host certificates: %s" (Printexc.to_string e)

let restart ~__context ~accept =
  try
    info "Restarting stunnel (accepting connections on %s)" accept ;
    Config.update ~accept ;
    (* we do not worry about generating certificates here, because systemd will handle this for us, via the gencert service *)
    if not @@ is_enabled () then systemctl_ "enable" ;
    systemctl_ "restart" ;
    (* the stunnel start may have caused gencert to generate new certificates: now sync the DB *)
    update_certificates ~__context ()
  with e ->
    Backtrace.is_important e ;
    D.error "Xapi_stunnel.restart: failed to restart stunnel" ;
    raise e
